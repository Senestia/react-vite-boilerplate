---
globs: app/*
alwaysApply: false
---

## Purpose

Concise, enforceable rules for building front-end features in this repo.

## Tech Stack & Mode

- Vite + React Router v7 (Framework Mode, no SSR) + Tailwind CSS v4 + TypeScript
- Follow React Router v7 best practices; use file-based routing under `app/`
- Use React Query for client-side caching/fetching of non-blocking data

## Structure & Organization

- Route entry per folder: `index.tsx`
- Segment layout per folder: `layout.tsx` (presentational only; one per segment)
- Page folders may include: `components/`, `containers/`, `hooks/`, `services/`, `constants/`, `repositories/`, `types/`, `utils/`
- Shared, reusable assets live in `app/shared/`
- Tests live under `tests/`, mirroring feature structure

```
app/routes/
├── home/
│   ├── components/
│   └── index.tsx             # Home route component
├── notFound/
│   ├── components/
│   └── index.tsx             # Page not found route component
├── [page-name]/
│   │   └── $[path]           # Optional nested dynamic route
│   ├── layout.tsx            # Optional layout route for this segment
│   ├── index.tsx             # Main route component
│   ├── components/           # Page-specific UI components
│   ├── containers/           # Page-specific business logic containers
│   ├── hooks/                # Page-specific custom hooks
│   ├── services/             # Page-specific API services
│   ├── constants/            # Page-specific constants and static data
│   ├── repositories/         # Page-specific data provider definitions
│   ├── types/                # Page-specific TypeScript definitions
│   └── utils/                # Page-specific utility functions
└── layout/
tests/
├── routes/[page-name]/
└── shared/
```

## Repositories & HTTP

- Repositories are pure data providers (no React). Return typed models and propagate errors. No side effects
- Place repositories under `app/routes/[page]/repositories/` or `app/shared/repositories/` (if shared)
- Centralize HTTP clients and endpoints in `app/shared/utils/` and `app/shared/constants/`. Do not create feature-local Axios instances

## Barrels (index.ts)

- Use only when a folder has 3+ related peers or to expose a module’s public API
- One barrel per folder; export-only (no side effects); no chained re-exports
- Do not re-export across route segment boundaries
- No barrels in `components/` or `containers/`
- Inside a folder with a barrel, source files must import siblings directly (never from the barrel) and must not re-export themselves

### Types organization

- Split type definitions into focused files by model (e.g., `pokemonListItem.ts`, `pokemonDetail.ts`)
- Add a local barrel in the `types/` folder to expose the public types API
- Import from the folder barrel within the route segment (e.g., `import type { PokemonDetail } from "../types"`)

## Naming

- Components: PascalCase (e.g., `UserProfile.tsx`)
- Hooks: camelCase starting with `use` (e.g., `useUserData.ts`)
- Services: camelCase ending with `Service` (e.g., `userService.ts`)
- Barrels are always named `index.ts`

## Components vs Containers

- Components: presentational only (no data fetching/business logic)
- Containers: state, effects, API calls; compose components
- Never mix fetching and UI in the same file

## Code Quality

- Small, focused files (components ≤ 150 lines; any file ≤ 500 lines)
- Destructure props/state; prefer modern ES features and async/await
- Strict TypeScript; no `any`
- DRY: extract shared logic into hooks/utils/shared components
- Extract oversized components into smaller subcomponents. Keep extracted parts within the current route scope; if reused by sibling pages/components, move to the parent route segment; if reused across features, promote to `app/shared/components/`
- Extract small, reusable presentational atoms (e.g., badges, chips, pills) into dedicated components within the route segment’s `components/` folder; keep them stateless and style-only. If reused across features, promote to `app/shared/components/` with clear props
- Extract cohesive presentational sections (e.g., Abilities list, Stats grid) into small components in the page’s `components/` folder. Inputs are plain data via props; no fetching or mutations. Favor composition in containers/pages

## React Router v7

- File-based routing by default
- Loaders: only for URL-driven or must-block-first-paint data, or to handle errors
- Actions: for form submissions/mutations
- Lazy-load routes by default; use layout routes for guards

## Data Loading

- Non-blocking/interactive data: fetch in containers/hooks after render via repositories
- Provide `ErrorBoundary` for failures

### Client Loaders with React Query and Zustand

- Use client loaders to pre-seed React Query cache for data needed immediately on navigation; return `null` from the loader
- Shape: curry the loader with a `QueryClient`
  - `export const clientLoader = (queryClient: QueryClient) => async (args) => { ... }`
- Read ephemeral inputs from Zustand using `store.getState()` only (never React hooks inside loaders)
  - Example: `const limit = useFeatureStore.getState().listLimit`
- Validate URL params and throw `new Response(message, { status: 400 })` for client errors
- Prefetch using repository functions; define route-local stable query keys under a `keys` object
  - For single page: `queryClient.prefetchQuery({ queryKey, queryFn })`
  - For infinite lists: `queryClient.prefetchInfiniteQuery({ queryKey, initialPageParam, queryFn, getNextPageParam, pages: 1 })`
- Do not return fetched data from client loaders; components should call `useQuery`/`useInfiniteQuery` with the same `queryKey` to reuse the cache
- Keep loaders side-effect free (no store writes). Set store state from components/effects instead

Example (infinite list):

```ts
const keys = {
  listInfinite: (limit: number) =>
    ["entity", "list", "infinite", limit] as const,
}

export const clientLoader = (queryClient: QueryClient) => async () => {
  const limit = useUiStore.getState().listLimit
  await queryClient.prefetchInfiniteQuery({
    queryKey: keys.listInfinite(limit),
    initialPageParam: 0,
    queryFn: ({ pageParam }) =>
      repository.fetchListPage({ limit, offset: pageParam }),
    getNextPageParam: (lastPage) => lastPage.nextOffset ?? undefined,
    pages: 1,
  })
  return null
}
```

Example (detail by URL param):

```ts
const keys = { byId: (id: string) => ["entity", "detail", id] as const }

export const clientLoader =
  (queryClient: QueryClient) =>
  async ({ params }: Route.ClientLoaderArgs) => {
    const id = params.id?.toString() ?? ""
    if (!id) throw new Response("Missing id", { status: 400 })
    await queryClient.prefetchQuery({
      queryKey: keys.byId(id),
      queryFn: () => repository.fetchById(id),
    })
    return null
  }
```

### React Query

- Initialize a single `QueryClient` and wrap the app with `QueryClientProvider` in `app/root.tsx`
- Prefer `useQuery`/`useInfiniteQuery`/`useMutation` for client-side data. Reuse repository functions as query functions
- Client loaders should prefetch into the cache via `prefetchQuery`/`prefetchInfiniteQuery` and return `null`; components then call `useQuery`/`useInfiniteQuery` with the same `queryKey` to consume cached data (no `initialData` needed when prefetching)
- Define stable query keys under a local `keys` object per route segment (e.g., `const keys = { list: (limit:number)=>["pokemon","list",limit], byName: (name:string)=>["pokemon","detail",name] }`)
- Handle errors via `ErrorBoundary`; in components, surface loading and empty states

## State Management (Zustand)

- Use Zustand for ephemeral UI/app state only (e.g., filter values, selected IDs, toggles). Do not store server-fetched entities; use React Query for server data
- Co-locate feature-specific stores under the route segment in `hooks/` or `state/` folders; promote cross-feature state to `app/shared/stores/`
- Stores are plain, framework-agnostic modules. No React imports inside stores
- Keep state minimal and serializable; expose small actions; prefer selectors in components to avoid re-renders
- Access store outside React via `store.getState()` in loaders or utilities when needed; avoid writing to stores inside loaders
- Optional persistence: use middleware only when justified; default to in-memory

## Styling (Tailwind v4)

- Prefer utilities over custom CSS; create reusable variants
- Mobile-first; use semantic HTML; avoid unnecessary wrapper elements
- Organize CSS in `app.css`, `components.css`, `utilities.css`

## React Practices

- Functional components with explicit prop interfaces; use default parameters instead of `defaultProps`
- Memoize (`React.memo`, `useMemo`, `useCallback`) when it measurably prevents re-renders
- Lists require stable, unique `key` props

## AI-Friendly Patterns

- Descriptive names; explicit types for public APIs; JSDoc for complex/public modules
- Single-purpose files; predictable folder layout; explicit exports and dependencies

## Testing

- Tests under `tests/`, mirroring features; name files `*.test.tsx` or `*.spec.tsx`
- Use React Testing Library; test behavior; mock external deps only
- Aim for ≥ 80% coverage on critical paths; use factories/fixtures

## Performance & Monitoring

- Code-split at route level by default; split large components when helpful
- Optimize assets; leverage browser caching; monitor bundle sizes
- Track Core Web Vitals; enable error tracking; maintain a performance budget; run periodic perf/a11y audits
