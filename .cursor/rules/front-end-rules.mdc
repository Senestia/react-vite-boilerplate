---
globs: app/*
alwaysApply: false
---

## Purpose

Concise, enforceable rules for building front-end features in this React Router v7 + Vite + Tailwind + TypeScript codebase.

## Structure & Organization

- Route entry per folder: `index.tsx`
- Segment layout per folder: `layout.tsx` (presentational only; one per segment)
- Page folders may include: `components/`, `containers/`, `hooks/`, `services/`, `constants/`, `repositories/`, `stores/`, `types/`, `utils/`
- Shared, reusable assets live in `app/shared/`
- Tests live under `tests/`, mirroring feature structure

```
app/routes/
├── home/
│   ├── components/
│   └── index.tsx             # Home route component
├── notFound/
│   ├── components/
│   └── index.tsx             # Page not found route component
├── [page-name]/
│   │   └── $[path]           # Optional nested dynamic route
│   ├── layout.tsx            # Optional layout route for this segment
│   ├── index.tsx             # Main route component
│   ├── components/           # Page-specific UI components
│   ├── containers/           # Page-specific business logic containers
│   ├── hooks/                # Page-specific custom hooks
│   ├── services/             # Page-specific API services
│   ├── constants/            # Page-specific constants and static data
│   ├── repositories/         # Page-specific data provider definitions
│   ├── stores/               # Page-specific Zustand stores
│   ├── types/                # Page-specific TypeScript definitions
│   └── utils/                # Page-specific utility functions
└── layout/
tests/
├── routes/[page-name]/
└── shared/
```

## Code Architecture

**Components vs Containers vs Hooks**

- **Components**: presentational only (no fetching, minimal state)
- **Containers**: compose components + hooks; handle UI concerns (refs, observers)
- **Custom Hooks**: business logic, state management, side effects
- Never mix fetching and UI in the same file
- Extract all React Query logic into custom hooks
- Create reusable utility hooks for common patterns (intersection observers, form validation)
- Co-locate hooks in `hooks/` folder; use barrels for 3+ related hooks

**Naming Conventions**

- Components: PascalCase (`UserProfile.tsx`)
- Hooks: camelCase with `use` prefix (`useUserData.ts`)
- Services: camelCase with `Service` suffix (`userService.ts`)
- Barrels: always `index.ts`

**Barrels & Types**

- Use barrels only for 3+ related files or public APIs; no chained re-exports
- No barrels in `components/` or `containers/`
- Split types into focused files (`pokemonDetail.ts`, `pokemonListItem.ts`)
- Add barrel in `types/` folder; import from barrel within route segment

## Data Management

**Repositories & HTTP**

- Pure data providers (no React); return typed models; propagate errors
- Place in `app/routes/[page]/repositories/` or `app/shared/repositories/`
- Centralize HTTP clients in `app/shared/utils/` and endpoints in `app/shared/constants/`

**React Query**

- Single `QueryClient` in `app/root.tsx`; use `useQuery`/`useInfiniteQuery`/`useMutation`
- **Always extract React Query logic into custom hooks**; never use directly in components/containers
- Define stable query keys: `const keys = { list: (limit) => ["pokemon", "list", limit] }`
- Handle errors via `ErrorBoundary`; surface loading/empty states in components
- Export query keys from hooks for clientLoader consistency

**Zustand State**

- For ephemeral UI state only (filters, toggles); use React Query for server data
- Co-locate stores in `stores/` folders; promote to `app/shared/stores/` if shared across routes
- Plain modules (no React imports); minimal serializable state; small actions

**Client Loaders**

- Pre-seed React Query cache; return `null`; curry with `QueryClient`
- Read Zustand via `store.getState()` only; validate params; throw `Response` for errors

```ts
export const clientLoader =
  (queryClient: QueryClient) =>
  async ({ params }) => {
    const id = params.id ?? ""
    if (!id) throw new Response("Missing id", { status: 400 })
    await queryClient.prefetchQuery({
      queryKey: ["entity", "detail", id],
      queryFn: () => repository.fetchById(id),
    })
    return null
  }
```

## Development Practices

**Code Quality**

- Small files: components ≤150 lines, any file ≤500 lines
- Destructure props; use modern ES features; strict TypeScript (no `any`)
- Extract shared logic; promote reusable components to appropriate scope
- Single-purpose files; descriptive names; explicit types for public APIs

**React Patterns**

- Functional components with explicit prop interfaces; default parameters over `defaultProps`
- Memoize only when measurably preventing re-renders
- Stable, unique `key` props for lists

## Routing & Performance

**React Router v7**

- File-based routing; loaders for URL-driven/blocking data only
- Actions for form submissions; lazy-load routes; layout routes for guards

**Optimization**

- Code-split at route level; optimize assets; monitor bundle sizes
- Track Core Web Vitals; maintain performance budget

## Styling & Testing

**Tailwind v4**

- Utilities over custom CSS; mobile-first; semantic HTML
- Organize in `app.css`, `components.css`, `utilities.css`

**Testing**

- Tests under `tests/` mirroring features; `*.test.tsx` naming
- React Testing Library; test behavior; ≥80% coverage on critical paths
