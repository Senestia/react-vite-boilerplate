---
globs: app/*
alwaysApply: false
---

## Purpose

Concise, enforceable rules for building front-end features in this repo.

## Tech Stack & Mode

- Vite + React Router v7 (Framework Mode, no SSR) + Tailwind CSS v4 + TypeScript
- Follow React Router v7 best practices; use file-based routing under `app/`
- Use Redux Toolkit with RTK Query for state management and data fetching

## Structure & Organization

- Route entry per folder: `index.tsx`
- Segment layout per folder: `layout.tsx` (presentational only; one per segment)
- Page folders may include: `components/`, `containers/`, `hooks/`, `services/`, `constants/`, `repositories/`, `slices/`, `types/`, `utils/`
- Shared, reusable assets live in `app/shared/`
- Tests live under `tests/`, mirroring feature structure

```
app/routes/
├── home/
│   ├── components/
│   └── index.tsx             # Home route component
├── notFound/
│   ├── components/
│   └── index.tsx             # Page not found route component
├── [page-name]/
│   │   └── $[path]           # Optional nested dynamic route
│   ├── layout.tsx            # Optional layout route for this segment
│   ├── index.tsx             # Main route component
│   ├── components/           # Page-specific UI components
│   ├── containers/           # Page-specific business logic containers
│   ├── hooks/                # Page-specific custom hooks
│   ├── services/             # Page-specific API services
│   ├── constants/            # Page-specific constants and static data
│   ├── repositories/         # Page-specific data provider definitions
│   ├── slices/               # Page-specific Redux slices
│   ├── types/                # Page-specific TypeScript definitions
│   └── utils/                # Page-specific utility functions
└── layout/
tests/
├── routes/[page-name]/
└── shared/
```

## Architecture Patterns

### Components vs Containers vs Custom Hooks

- **Components**: presentational only (no data fetching/business logic, minimal state)
- **Containers**: compose components and custom hooks; handle UI-specific concerns (refs, Intersection Observers)
- **Custom Hooks**: business logic, Redux state management, RTK Query calls, complex side effects
- Never mix fetching and UI in the same file; prefer custom hooks for business logic encapsulation

### Custom Hook Organization

- Place in `hooks/` folders within route segments
- Name with `use` prefix + clear functionality (`useInfiniteScroll`, `usePokemonFilters`)
- Export from barrel files when folder has 3+ hooks
- Pure business logic only - no JSX, refs, or DOM manipulation
- One primary concern per hook; avoid deep nesting

## Code Quality & Organization

### File Structure

- Small, focused files (components ≤ 150 lines; any file ≤ 500 lines)
- Strict TypeScript; no `any`
- Extract oversized components into subcomponents within current route scope
- Promote to `app/shared/` only when reused across features

### Barrels (index.ts)

- Use only when folder has 3+ related peers or to expose module's public API
- One barrel per folder; export-only; no chained re-exports across route boundaries
- No barrels in `components/` or `containers/`
- Source files import siblings directly (never from barrel)

### Types Organization

- Split into focused files by model (`pokemonListItem.ts`, `pokemonDetail.ts`)
- Add barrel in `types/` folder to expose public API
- Import from folder barrel within route segment

### Naming Conventions

- Components: PascalCase (`UserProfile.tsx`)
- Hooks: camelCase with `use` prefix (`useUserData.ts`)
- Services: camelCase with `Service` suffix (`userService.ts`)
- Barrels: always `index.ts`

## Data Management

### HTTP & Repositories

- Repositories are pure data providers (no React); return typed models and propagate errors
- Place under `app/routes/[page]/repositories/` or `app/shared/repositories/`
- Centralize HTTP clients in `app/shared/utils/` and endpoints in `app/shared/constants/`
- Prefer RTK Query API endpoints in slice files over separate repository functions

### Client Loaders

- Use for RTK Query prefetching on navigation; always return `null`
- Curry with Redux store: `export const clientLoader = (store: AppStore) => async (args) => { ... }`
- Read state via `store.getState()` only (no React hooks)
- Validate URL params; throw `new Response(message, { status: 400 })` for errors
- Prefetch with `forceRefetch: false`

### RTK Query

- Define API endpoints using `createApi` with `fetchBaseQuery`
- Organize endpoints by feature domain in `slices/` folders
- Use generated hooks in components (`useGetEntitiesQuery`, `useUpdateEntityMutation`)
- Handle errors via `ErrorBoundary` and RTK Query error states

## State Management (Redux Toolkit)

### Organization

- Co-locate feature slices in route segment `slices/` folders
- Promote cross-feature slices to `app/shared/slices/`
- Use `createSlice` with Immer for immutable updates
- Configure store with RTK Query API slices

### Best Practices

- **Never mix local state with Redux state** - single source of truth
- **Encapsulate business logic in custom hooks** - avoid direct `useAppDispatch` in components
- **Custom hooks return clean interfaces** - only what components need for rendering
- **Descriptive action names** - domain-specific (`setInitialPokemonList` vs `updateArray`)

### What to Share vs Keep Local

**Share:**

- Generic components across features
- Cross-cutting utilities (HTTP, validation)
- Global app state (user session, theme)
- Common types and constants

**Keep Local:**

- Feature-specific UI state (pagination, filters)
- Feature-specific business logic
- Component state for single features

## React Router v7 & Data Loading

- File-based routing; lazy-load routes by default
- Loaders: only for URL-driven or must-block-first-paint data
- Actions: for form submissions/mutations
- Non-blocking data: fetch in containers/hooks via RTK Query
- Provide `ErrorBoundary` for failures

## Development Standards

### React Practices

- Functional components with explicit prop interfaces
- Use default parameters instead of `defaultProps`
- Memoize only when it measurably prevents re-renders
- Lists require stable, unique `key` props

### Styling (Tailwind v4)

- Prefer utilities over custom CSS; mobile-first approach
- Use semantic HTML; avoid unnecessary wrapper elements
- Organize CSS in `app.css`, `components.css`, `utilities.css`

### Testing & Performance

- Tests under `tests/` mirroring features; use React Testing Library
- Code-split at route level; monitor bundle sizes
- Track Core Web Vitals; maintain performance budget
