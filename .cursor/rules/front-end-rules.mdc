---
globs: app/*
alwaysApply: false
---

## Purpose

Concise, enforceable rules for building front-end features in this repo.

## Tech Stack & Mode

- Vite + React Router v7 (Framework Mode, no SSR) + Tailwind CSS v4 + TypeScript
- Follow React Router v7 best practices; use **programmatic routing** with explicit route configuration in `routes.ts` (NOT file-based routing)
- Use Redux Toolkit with RTK Query for state management and data fetching

## Structure & Organization

- **Module-based**: Group routes by domain/feature (auth, pokemon)
- **Route files**: Named by URL path (login.tsx) not \_index.tsx
- **Semantic dynamic routes**: detail.tsx, edit.tsx, settings.tsx
- **Module layouts**: layout.tsx or [scope]-layout.tsx wraps all routes in module

```
app/routes/
├── home/
│   ├── home.tsx                       # / route
│   └── components/                    # Module-specific components only
├── not-found/
│   ├── not-found.tsx                  # catch-all route
│   └── components/                    # Module-specific components only
├── auth/                              # Authentication module
│   ├── layout.tsx                     # Auth module layout (wraps all auth routes)
│   ├── login.tsx                      # /auth/login route
│   ├── register.tsx                   # /auth/register routenpm run test
│   ├── forgot-password.tsx            # /auth/forgot-password route
│   ├── components/                    # Auth-specific UI components
│   ├── hooks/                         # Auth-specific custom hooks
│   ├── types/                         # Auth-specific TypeScript definitions
│   └── slices/                        # Auth-specific Redux slices
├── pokemon/                           # Pokemon module
│   ├── layout.tsx                     # Pokemon module layout (wraps all pokemon routes)
│   ├── list.tsx                       # /pokemon route (list page)
│   ├── detail.tsx                     # /pokemon/:name route (detail page)
│   ├── components/                    # Pokemon-specific UI components
│   │   ├── PokemonList.tsx            # Shared across multiple routes
│   │   ├── PokemonListItem.tsx        # Used by list route
│   │   └── PokemonDetails.tsx         # Used by detail route
│   ├── containers/                    # Pokemon-specific containers
│   │   ├── PokemonExplorer.tsx        # Used by list route
│   │   └── PokemonDetailsContainer.tsx # Used by detail route
│   ├── hooks/                         # Pokemon-specific custom hooks
│   ├── slices/                        # Pokemon-specific Redux slices
│   └── types/                         # Pokemon-specific TypeScript definitions
├── [module-name]/                     # Additional modules follow same pattern
│   ├── layout.tsx                     # Module layout (optional)
│   ├── [route-name].tsx               # Module routes named by URL path
│   ├── [semantic-name].tsx            # Dynamic routes with semantic names
│   └── [folders]/                     # Module-specific resources
└── layout.tsx                         # Root layout (optional)
tests/
├── routes/                            # MUST mirror app/routes structure exactly
│   └── [module-name]/
└── shared/                            # Test shared utilities and components
```

## Architecture Patterns

### Module Organization Guidelines

- **Module Boundaries**: Each module represents a distinct domain/feature (auth, pokemon, admin, etc.)
- **Route Naming**: Files named by their URL path - `login.tsx` for `/auth/login`, not `_index.tsx`
- **Dynamic Route Naming**: Use semantic names describing the route's purpose - `detail.tsx` for detail pages, `edit.tsx` for edit pages. Since we use programmatic routing (NOT file-based), avoid file-based patterns like `$name/` folders - all components and containers should be organized within the module's main `components/` and `containers/` folders
- **Module Layouts**: `layout.tsx` or `[scope]-layout.tsx` in module folders wraps all routes within that module
- **Module Resources**: Each module owns its components, hooks, types, slices within its folder
- **Cross-Module Dependencies**: Prefer shared utilities in `app/shared/` over direct imports between modules
- **Module Size**: Split large modules into sub-modules when they exceed 10-15 route files

### Route Configuration Example

**This is programmatic routing - routes are explicitly defined in `routes.ts`, NOT derived from file structure:**

```typescript
// routes.ts
export default [
  layout("/auth", "routes/auth/layout.tsx", [
    route("login", "routes/auth/login.tsx"), // /auth/login
    route("register", "routes/auth/register.tsx"), // /auth/register
    route("forgot-password", "routes/auth/forgot-password.tsx"), // /auth/forgot-password
  ]),
  layout("routes/layout.tsx", [
    index("routes/home.tsx"), // /
    route("/pokemon", "routes/pokemon/layout.tsx", [
      index("routes/pokemon/list.tsx"), // /pokemon
      route(":name", "routes/pokemon/detail.tsx"), // /pokemon/:name
    ]),
    route("/admin", "routes/admin/layout.tsx", [
      index("routes/admin/dashboard.tsx"), // /admin
      route("users", "routes/admin/users.tsx"), // /admin/users
      route("users/:id/edit", "routes/admin/edit-user.tsx"), // /admin/users/:id/edit
    ]),
    route("*", "routes/not-found.tsx"), // 404
  ]),
] satisfies RouteConfig
```

### Components vs Containers vs Custom Hooks

- **Components**: presentational only (no data fetching/business logic, minimal state)
- **Containers**: compose components and custom hooks; handle UI-specific concerns (refs, Intersection Observers)
- **Custom Hooks**: business logic, Redux state management, RTK Query calls, complex side effects
- Never mix fetching and UI in the same file; prefer custom hooks for business logic encapsulation

### Custom Hook Organization

- Place in `hooks/` folders within route segments
- Name with `use` prefix + clear functionality (`useInfiniteScroll`, `usePokemonFilters`)
- Export from barrel files when folder has 3+ hooks
- Pure business logic only - no JSX, refs, or DOM manipulation
- One primary concern per hook; avoid deep nesting

## Code Quality & Organization

### File Structure

- Small, focused files (components ≤ 150 lines; any file ≤ 500 lines)
- Strict TypeScript; no `any`
- Extract oversized components into subcomponents within current route scope
- Promote to `app/shared/` only when reused across features

### Barrels (index.ts)

- Use only when folder has 3+ related peers or to expose module's public API
- One barrel per folder; export-only; no chained re-exports across route boundaries
- No barrels in `components/` or `containers/`
- Source files import siblings directly (never from barrel)

### Types Organization

- Split into focused files by model (`pokemonListItem.ts`, `pokemonDetail.ts`)
- Add barrel in `types/` folder to expose public API
- Import from folder barrel within route segment

### Naming Conventions

- **Route Files**: kebab-case matching URL path (`login.tsx`, `forgot-password.tsx`)
- **Dynamic Routes**: Semantic names describing purpose (`detail.tsx`, `edit.tsx`, `settings.tsx`)
- **Module Layouts**: `layout.tsx` or `[scope]-layout.tsx` within module folders
- **Components**: PascalCase (`UserProfile.tsx`)
- **Hooks**: camelCase with `use` prefix (`useUserData.ts`)
- **Services**: camelCase with `Service` suffix (`userService.ts`)
- **Modules**: kebab-case folder names (`auth/`, `user-profile/`)
- **Barrels**: always `index.ts`

### Common Dynamic Route Names

- `detail.tsx` - For showing individual item details (`/pokemon/:name`, `/users/:id`)
- `edit.tsx` - For editing individual items (`/users/:id/edit`, `/posts/:id/edit`)
- `settings.tsx` - For settings pages (`/users/:id/settings`)
- `dashboard.tsx` - For dashboard/overview pages (`/admin`, `/user/:id/dashboard`)

### Anti-Patterns to Avoid

- **NEVER use `$name/`, `$id/`, or similar parameter-based folder structures** - these are React Router file-based routing patterns that don't apply to our programmatic routing approach
- **NEVER organize components/containers by route parameters** - all components and containers belong in the module's main folders
- **ALWAYS use semantic route files** (`detail.tsx`, `edit.tsx`) that import from the module's shared `components/` and `containers/` folders

## Data Management

### HTTP & Repositories

- Repositories are pure data providers (no React); return typed models and propagate errors
- Place under `app/routes/[page]/repositories/` or `app/shared/repositories/`
- Centralize HTTP clients in `app/shared/utils/` and endpoints in `app/shared/constants/`
- Prefer RTK Query API endpoints in slice files over separate repository functions

### Client Loaders

- Use for RTK Query prefetching on navigation; always return `null`
- Curry with Redux store: `export const clientLoader = (store: AppStore) => async (args) => { ... }`
- Read state via `store.getState()` only (no React hooks)
- Validate URL params; throw `new Response(message, { status: 400 })` for errors
- Prefetch with `forceRefetch: false`

### RTK Query

- Define API endpoints using `createApi` with `fetchBaseQuery`
- Organize endpoints by feature domain in `slices/` folders
- Use generated hooks in components (`useGetEntitiesQuery`, `useUpdateEntityMutation`)
- Handle errors via `ErrorBoundary` and RTK Query error states

## State Management (Redux Toolkit)

### Organization

- Co-locate feature slices in route segment `slices/` folders
- Promote cross-feature slices to `app/shared/slices/`
- Use `createSlice` with Immer for immutable updates
- Configure store with RTK Query API slices

### Best Practices

- **Never mix local state with Redux state** - single source of truth
- **Encapsulate business logic in custom hooks** - avoid direct `useAppDispatch` in components
- **Custom hooks return clean interfaces** - only what components need for rendering
- **Descriptive action names** - domain-specific (`setInitialPokemonList` vs `updateArray`)

### What to Share vs Keep Local

**Share:**

- Generic components across features
- Cross-cutting utilities (HTTP, validation)
- Global app state (user session, theme)
- Common types and constants

**Keep Local:**

- Feature-specific UI state (pagination, filters)
- Feature-specific business logic
- Component state for single features

## React Router v7 & Data Loading

- **Programmatic routing** configuration in `routes.ts` (NOT file-based routing); lazy-load routes by default
- Loaders: only for URL-driven or must-block-first-paint data
- Actions: for form submissions/mutations
- Non-blocking data: fetch in containers/hooks via RTK Query
- Provide `ErrorBoundary` for failures

## Development Standards

### React Practices

- Functional components with explicit prop interfaces
- Use default parameters instead of `defaultProps`
- Memoize only when it measurably prevents re-renders
- Lists require stable, unique `key` props

### Styling (Tailwind v4)

- Prefer utilities over custom CSS; mobile-first approach
- Use semantic HTML; avoid unnecessary wrapper elements
- Organize CSS in `app.css`, `components.css`, `utilities.css`

### Testing & Performance

**Test Structure Requirements:**

- **MUST mirror route structure exactly** - `tests/routes/` mirrors `app/routes/`
- **Test naming matches route naming** - `login.test.tsx` for `login.tsx`, `detail.test.tsx` for `detail.tsx`
- **Module boundaries respected** - each route module has corresponding test module
- **Component/container/hook tests** - place in same relative folders as source files

**Test Organization:**

- Route tests: `tests/routes/[module]/[route-name].test.tsx`
- Component tests: `tests/routes/[module]/components/[Component].test.tsx`
- Container tests: `tests/routes/[module]/containers/[Container].test.tsx`
- Hook tests: `tests/routes/[module]/hooks/[hookName].test.ts`
- Shared tests: `tests/shared/[category]/[item].test.tsx`

**Performance:**

- Use React Testing Library for all component tests
- Code-split at route level; monitor bundle sizes
- Track Core Web Vitals; maintain performance budget
